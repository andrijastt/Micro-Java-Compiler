

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, CONST, CLASS, IF, ELSE, WHILE, BREAK, CONTINUE, NEW;
terminal PRINT, READ, RETURN, VOID, EXTENDS, FOREACH;
terminal TRUE, FALSE;
terminal CHAR;
terminal Integer NUMBER;
terminal String IDENT;
terminal PLUS, MINUS, MULTIPLY, DIVISION, MOD;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR, INC, DEC, ASSIGN;
terminal SEMI, DOUBLE_DOT, COMMA, DOT;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal POINTER_LIKE;

nonterminal Program Program;
nonterminal ParamList ParamList;
nonterminal ParamItem ParamItem;
nonterminal MethodDeclList MethodDeclList; 
nonterminal ConstDecl ConstDecl;
nonterminal ConstDeclList ConstDeclList;
nonterminal Const Const;
nonterminal ConstVal ConstVal;
nonterminal ConstComma ConstComma;
nonterminal ConstSemi ConstSemi; 
nonterminal VarDeclList VarDeclList;
nonterminal VarDecl VarDecl;
nonterminal VarSemi VarSemi;
nonterminal VarComma VarComma;
nonterminal Var Var;
nonterminal Type Type;
nonterminal MethodDecl MethodDecl;
nonterminal MethodVarDecl MethodVarDecl;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal Designator Designator;
nonterminal Expr Expr;
nonterminal Term Term;
nonterminal Assignop Assignop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal Factor Factor;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal DesignatorList DesignatorList;
nonterminal DesignatorTemp DesignatorTemp;
nonterminal NumConstList NumConstList;

Program ::= (Program) PROG IDENT:I1 ParamList:P2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(I1, P2, M3); RESULT.setLine(I1left); :};

ParamList ::= (ParamItemList) ParamList:P1 ParamItem:P2 {: RESULT=new ParamItemList(P1, P2); RESULT.setLine(P1left); :}
			|
			(NoParamItem) {: RESULT=new NoParamItem(); :}
			;
			
ParamItem ::= (ParamConstList) ConstDecl:C1 {: RESULT=new ParamConstList(C1); RESULT.setLine(C1left); :}
			|
			(ParamVarList) VarDecl:V1 {: RESULT=new ParamVarList(V1); RESULT.setLine(V1left); :}; 

ConstDecl ::= (ConstDeclaration) CONST Type:constType ConstDeclList:C1 {: RESULT=new ConstDeclaration(constType, C1); RESULT.setLine(constTypeleft); :};

ConstDeclList ::= (ConstList) ConstComma:C1 ConstDeclList:C2 {: RESULT=new ConstList(C1, C2); RESULT.setLine(C1left); :}
				|
				(SingleConst) ConstSemi:C1 {: RESULT=new SingleConst(C1); RESULT.setLine(C1left); :}
				;
						
ConstSemi ::= (SemiConst) Const:C1 SEMI {: RESULT=new SemiConst(C1); RESULT.setLine(C1left); :}
			|
			(ConstSemiError) error SEMI:l
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new ConstSemiError(); :}
			;
	
ConstComma ::= (CommaConst) Const:C1 COMMA {: RESULT=new CommaConst(C1); RESULT.setLine(C1left); :}
			|
			(ConstCommaError) error COMMA:l
			{: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null);  :} {: RESULT=new ConstCommaError(); :}
			;
				
Const ::= (Const) IDENT:constName ASSIGN ConstVal:C1 {: RESULT=new Const(constName, C1); RESULT.setLine(constNameleft); :};
			
ConstVal ::= (NumConst) NUMBER:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :}
			|
			(CharConst) CHAR {: RESULT=new CharConst(); :}
			|
			(TrueConst) TRUE {: RESULT=new TrueConst(); :}
			|
			(FalseConst) FALSE {: RESULT=new FalseConst(); :}
			;

MethodVarDecl ::= (MethodVarDecls) MethodVarDecl:M1 VarDecl:V2 {: RESULT=new MethodVarDecls(M1, V2); RESULT.setLine(M1left); :}
		|
		(NoMethodVarDecls) {: RESULT=new NoMethodVarDecls(); :}
		;

VarDecl ::= (VarDeclaration) Type:varType VarDeclList:V1 {: RESULT=new VarDeclaration(varType, V1); RESULT.setLine(varTypeleft); :};

VarDeclList ::= (VarList) VarComma:V1 VarDeclList:V2 {: RESULT=new VarList(V1, V2); RESULT.setLine(V1left); :}
				|
				(SingleVar) VarSemi:V1 {: RESULT=new SingleVar(V1); RESULT.setLine(V1left); :}
				;
				
VarComma ::= (CommaVar) Var:V1 COMMA {: RESULT=new CommaVar(V1); RESULT.setLine(V1left); :}
			|
			(VarCommaError) error COMMA:l
			{: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null);  :} {: RESULT=new VarCommaError(); :}
			;

VarSemi ::= (SemiVar) Var:V1 SEMI {: RESULT=new SemiVar(V1); RESULT.setLine(V1left); :}
			|
			(VarSemiError) error SEMI:l
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new VarSemiError(); :}
			;
			
Var ::= (VarNoBrackets) IDENT:varName {: RESULT=new VarNoBrackets(varName); RESULT.setLine(varNameleft); :}
		|
		(VarBrackets) IDENT:varName LBRACKET RBRACKET {: RESULT=new VarBrackets(varName); RESULT.setLine(varNameleft); :}
			;

MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :} /* mozda nepotrebno */
				|
				(NoMethodDecl) {: RESULT=new NoMethodDecl(); :} /* epsilon */
				;
				
MethodDecl ::= (VoidMethodDecl) VOID IDENT:methName LPAREN RPAREN MethodVarDecl:M1 LBRACE StatementList:S2 RBRACE {: RESULT=new VoidMethodDecl(methName, M1, S2); RESULT.setLine(methNameleft); :};

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};

StatementList ::= (Statements) StatementList:S1 Statement:S2 {: RESULT=new Statements(S1, S2); RESULT.setLine(S1left); :}
				|
				(NoStmt) {: RESULT=new NoStmt(); :} /* epsilon */
				;

Statement ::= (DesignatorStmt) DesignatorStatement:D1 SEMI {: RESULT=new DesignatorStmt(D1); RESULT.setLine(D1left); :}
		   |
		   (ReadStmt) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :}
		   |
		   (PrintStmt) PRINT LPAREN Expr:E1 NumConstList:N2 RPAREN SEMI {: RESULT=new PrintStmt(E1, N2); RESULT.setLine(E1left); :}
		   ;
		   
NumConstList ::= (NumConsts) NumConstList:N1 COMMA NUMBER:N2 {: RESULT=new NumConsts(N1, N2); RESULT.setLine(N1left); :}
				|
				(NoNumConsts) {: RESULT=new NoNumConsts(); :} /* epsilon */
				;

DesignatorStatement ::= (DesignatorAssign) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorAssign(D1, A2, E3); RESULT.setLine(D1left); :}
					|
					(DesignatorINC)Designator:D1 INC {: RESULT=new DesignatorINC(D1); RESULT.setLine(D1left); :}
					|
					(DesignatorDEC)Designator:D1 DEC {: RESULT=new DesignatorDEC(D1); RESULT.setLine(D1left); :}
					|
					(DesignatorStatementBrackets) LBRACKET DesignatorList:D1 RBRACKET ASSIGN Designator:D2 {: RESULT=new DesignatorStatementBrackets(D1, D2); RESULT.setLine(D1left); :}
					|
					(DesignatorStatementError) error SEMI:l
		   			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new DesignatorStatementError(); :}
					;

DesignatorTemp ::= (DesignatroTemp) Designator:D1 {: RESULT=new DesignatroTemp(D1); RESULT.setLine(D1left); :}
				|
				(NoDesignatroTemp) {: RESULT=new NoDesignatroTemp(); :}
				;
				
DesignatorList ::= (DesignatorLists) DesignatorList:D1 COMMA DesignatorTemp:D2 {: RESULT=new DesignatorLists(D1, D2); RESULT.setLine(D1left); :}
				|
				(SingleDesignatorList) DesignatorTemp:D1 {: RESULT=new SingleDesignatorList(D1); RESULT.setLine(D1left); :}
				;		

Expr ::= (NegativeExpr) MINUS Term:T1 Addop:A2 Expr:E3 {: RESULT=new NegativeExpr(T1, A2, E3); RESULT.setLine(T1left); :}
		|
		(PositiveExpr) Term:T1 Addop:A2 Expr:E3 {: RESULT=new PositiveExpr(T1, A2, E3); RESULT.setLine(T1left); :}
		|
		(SingleExpr) Term:T1 {: RESULT=new SingleExpr(T1); RESULT.setLine(T1left); :}
		|
		(SingleNegativeExpr) MINUS Term:T1 {: RESULT=new SingleNegativeExpr(T1); RESULT.setLine(T1left); :}
		;

Term ::= (TermExpr) Factor:t0 Mulop:M1 Term:t1 {: RESULT=new TermExpr(t0, M1, t1); RESULT.setLine(t0left); :}
		|
		(SignleTerm) Factor:t0 {: RESULT=new SignleTerm(t0); RESULT.setLine(t0left); :}
		;
				
Factor ::=(DisgnatorNoPars) Designator:d {: RESULT=new DisgnatorNoPars(d); RESULT.setLine(dleft); :}
		|
		(NumFactorConst) NUMBER:N1 {: RESULT=new NumFactorConst(N1); RESULT.setLine(N1left); :}
		|
		(CharFactorConst) CHAR {: RESULT=new CharFactorConst(); :}
		|
		(TrueFactorConst) TRUE {: RESULT=new TrueFactorConst(); :}
		|
		(FalseFactorConst) FALSE {: RESULT=new FalseFactorConst(); :}
		|
		(NewFuncExpr) NEW Type:typeName LBRACKET Expr:E1 RBRACKET {: RESULT=new NewFuncExpr(typeName, E1); RESULT.setLine(typeNameleft); :}
		|
		(Expression) LPAREN Expr:E1 RPAREN {: RESULT=new Expression(E1); RESULT.setLine(E1left); :}
		;

Designator ::= (DesignatorNoBrackets) IDENT:name {: RESULT=new DesignatorNoBrackets(name); RESULT.setLine(nameleft); :}
			|
			(DesignatorBrackets) IDENT:name LBRACKET Expr:E1 RBRACKET {: RESULT=new DesignatorBrackets(name, E1); RESULT.setLine(nameleft); :} 
			;
	
Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};

Addop ::= (Addop) PLUS {: RESULT=new Addop(); :}
		|
		(Minusop) MINUS {: RESULT=new Minusop(); :}
		;
		
Mulop ::= (Mulop) MULTIPLY {: RESULT=new Mulop(); :}
		|
		(Divop) DIVISION {: RESULT=new Divop(); :}
		|
		(Modop) MOD {: RESULT=new Modop(); :}
		;
			