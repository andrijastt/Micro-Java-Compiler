

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, CONST, CLASS, IF, ELSE, WHILE, BREAK, CONTINUE, NEW;
terminal PRINT, READ, RETURN, VOID, EXTENDS, FOREACH;
terminal TRUE, FALSE;
terminal APOS, CHAR;
terminal Integer NUMBER;
terminal String IDENT;
terminal PLUS, MINUS, MULTIPLY, DIVISION, MOD;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR, INC, DEC, ASSIGN;
terminal SEMI, DOUBLE_DOT, COMMA, DOT;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal POINTER_LIKE;

nonterminal Program, DeclList, DeclItem, MethodDeclList; 
nonterminal ConstDeclList, ConstDecl, Const, ConstVal; 
nonterminal VarDeclList, VarDecl, Var, VarVal, Type, MethodDecl;
nonterminal FormPars, FormalParamList, FormalParamDecl, StatementList, Statement;
nonterminal Designator, Expr, Term, Label, Assignop, Relop, Addop, Mulop, Factor, ActualPars, ActualParamList;
nonterminal DesignatorStatement, DesignatorList, Matched, Unmatched;

Program ::= (Program) PROG IDENT DeclList LBRACE MethodDeclList RBRACE;

DeclList ::= (AllDeclarations) DeclList DeclItem
			|
			(NoDeclarations) /* epsilon */
			;

DeclItem ::= (ConstDeclList) ConstDeclList
			|
			(VarDeclList) VarDeclList
			;

ConstDeclList ::= (ConstDeclarations) ConstDeclList ConstDecl
			|
			(NoConstDecl) /* epsilon */
			;
			
ConstDecl ::= (ConstDecl) CONST Type:constType Const SEMI;

Const ::= (SingleConst) IDENT:constName ASSIGN ConstVal
		|
		(MultipleConst) Const COMMA IDENT:constName ASSIGN ConstVal
		;

ConstVal ::= (IntVal) NUMBER
		|
		(CharVal) APOS CHAR APOS /* TODO i u flex CHAR */
		|
		(TrueVal) TRUE
		|
		(FalseVal) FALSE
		;

VarDeclList ::= (VarDeclarations) VarDeclList VarDecl
			|
			(NoVarDecl) /* epsilon */
			;

VarDecl ::= (VarDecl) Type:varType Var SEMI;

Var ::= (SingleVar) VarVal
		|
		(MultipleVar) Var COMMA VarVal
		;

VarVal ::= (VarNoBrackets) IDENT:varName 
		|
		(VarBrackets) IDENT:varName LBRACKET RBRACKET
		;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				|
				(NoMethodDecl) /* epsilon */
				;
				
MethodDecl ::= (RetMethodDecl) Type:retType IDENT:methName LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
			|
			(VoidMethodDecl) VOID IDENT:methName LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
			;

FormPars ::= (FormParams) FormalParamList
		  |
		  (NoFormParam) /* epsilon */
		  ;
		  
FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
				|
				(SingleFormalParamDecl) FormalParamDecl
				;
				
FormalParamDecl ::= (FormalParamBrackets) Type:formType IDENT:formName LBRACKET RBRACKET
					|
					(FormalParamNoBrackets) Type:formType IDENT:formName
					;

Type ::= (Type) IDENT:typeName;

StatementList ::= (Statements) StatementList Statement
				|
				(NoStmt) /* epsilon */
				;
				
Statement ::= (MatchedStmt) Matched
		   |
		   (UnmatchedStmt) Unmatched
		   ; 

Unmatched ::= (UnmatchedIf) IF Expr Statement
		 	|
		 	(UnmatchedIfElse) IF Expr Matched ELSE Unmatched
		 	;
		 

Matched ::= (Assignment) Designator:dest EQUAL Expr:e SEMI
		   |
		   (MatchedStatement) IF Expr Matched ELSE Matched
		   |
		   (WhileStmt) WHILE LPAREN Condition RPAREN Statement 
		   |
		   (ErrorStmt) error SEMI:l
		   {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :}
		   |
		   (BreakExpr) BREAK SEMI
		   |
		   (ContinueExpr) CONTINUE SEMI
		   |
		   (ReturnExpr) RETURN Expr:t SEMI
		   |
		   (ReturnNoExpr) RETURN SEMI
		   |
		   (ReadStmt) READ LPAREN Designator RPAREN SEMI
		   |
		   (PrintStmt) PRINT LPAREN Expr RPAREN SEMI
		   |
		   (BracketsStms) LBRACKET Statement RBRACKET
		   ;
		
DesignatorStatement ::= (DesignatorAssign) Designator Assignop Expr
					|
					(DesignatorActPars) Designator LPAREN ActPars RPAREN
					|
					(DesignatorINC)Designator INC
					|
					(DesignatorDEC)Designator DEC
					|
					(DesignatorBrackets) LBRACKET DesignatorList RBRACKET ASSIGN Designator
					;
					
DesignatorList ::= (DesignatorLists) Designator COMMA DesignatorList
				|
				(NoDesignatorList)
				;
		
ActualPars ::= (Actuals) ActualParamList
			|
			(NoActuals) /* epsilon */
			;
		
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
				|
				(ActualParam) Expr
				;

Condition ::= (SingleCondition) CondTerm
			|
			(OrCondition) CondTerm OR CondTerm
			;
			
CondTerm ::= (SingleCondFact) CondFact
			|
			(AndCondFact) CondFact AND CondFact
			;
			
CondFact ::= (SingleCondFact) Expr
			|
			(MultipleCondFact) Expr Relop Expr
			;

Expr ::= (NegativeExpr) MINUS Term Addop Term
		|
		(PositiveExpr) Term Addop Term
		|
		(SignleExpr) Term
		;

Term ::= (TermExpr) Factor:t0 MulOp Factor:t1
		|
		(SignleTerm) Factor:t0
		;
				
Factor ::=(DisgnatorNoPars) Designator:d
		|
		(DisgnatorPars) Designator:func LPAREN ActualPars RPAREN 
		|
		(NumConst) NUMBER
		|
		(TrueConst) TRUE
		|
		(FalseConst) False
		|
		(CharConst) APOS CHAR APOS /* TODO i u flex CHAR */
		|
		(NewFuncExpr) NEW Type:typeName LBRACKET Expr RBRACKET
		|
		(NewFuncActPars) NEW Type:typeName LPAREN ActualPars RPAREN
		|
		(Expresion) LPAREN Expr RPAREN
		;

Designator ::= (DesignatorNoBrackets) IDENT:name DOT IDENT:expr
			|
			(DesignatorBrackets) IDENT:name DOT LBRACKET Expr RBRACKET
			;

Label ::= (Label) IDENT;

Assignop ::= (Assignop) ASSIGN;

Relop ::= (Relop) EQUAL
		|
		(NEop) NOT_EQUAL
		|
		(Greaterop) GREATER
		|
		(GreaterEop) GREATER_EQUAL
		|
		(Lessop) LESS
		|
		(LessEop) LESS_EQUAL
		;

Addop ::= (Addop) PLUS
		|
		(Minusop) MINUS
		;
		
Mulop ::= (Mulop) MULTIPLY
		|
		(Divisonop) DIVISION
		|
		(Modop) MOD
		;
